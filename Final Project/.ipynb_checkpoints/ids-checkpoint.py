{
 "cells": [
  {
   "cell_type": "markdown",
   "id": "7b12cb25",
   "metadata": {},
   "source": [
    "# EE 418 Project\n",
    "\n",
    "Members: Simon Chen (1832768), \n",
    "Kejin Li (1978130), \n",
    "Andres Guerrero-Guzman (1066684), \n",
    "Khoa Tran (1861460)\n",
    "\n",
    "\n",
    "Contribution of Each Member:\n",
    "\n",
    "Simon Chen:\n",
    "\n",
    "Kejin Li:\n",
    "\n",
    "Andres Guerrero-Guzman: \n",
    "\n",
    "- TODO: Compute curr_avg_offset_us and curr_acc_offset_us for NTP-based IDS\n",
    "- TODO: Implement the RLS algorithm\n",
    "- TODO: 1) Normalize curr_error_sample, 2) compute curr_L_upper and curr_L_lower\n",
    "\n",
    "\n",
    "Khoa Tran:"
   ]
  },
  {
   "cell_type": "code",
   "execution_count": 5,
   "id": "8979740f",
   "metadata": {},
   "outputs": [],
   "source": [
    "\"\"\"\n",
    "This implements both state-of-the-art and NTP-based IDSs.\n",
    "\"\"\"\n",
    "\n",
    "import numpy as np\n",
    "\n",
    "__author__ = \"ee418\"\n",
    "\n",
    "\n",
    "class IDS:\n",
    "    def __init__(self, T_sec, N, mode):\n",
    "        if (mode != 'state-of-the-art') & (mode != 'ntp-based'):\n",
    "            raise ValueError('Unknown IDS mode')\n",
    "\n",
    "        self.mode = mode\n",
    "\n",
    "        self.k = 0  # Current batch\n",
    "        self.N = N  # Batch size\n",
    "        self.T_sec = T_sec # Nominal period in sec\n",
    "\n",
    "        self.mu_T_sec = 0            # Average inter-arrival time in the current batch (sec)\n",
    "        self.batch_end_time_sec = 0  # End time of every batch (sec)\n",
    "        self.init_time_sec = 0       # Arrival time of the 1st message in the 2nd batch (sec)\n",
    "        self.elapsed_time_sec = 0    # Elapsed time since the 1st message in the 2nd batch (sec)\n",
    "\n",
    "        self.acc_offset_us = 0  # Most recent accumulated offset (us)\n",
    "        self.avg_offset_us = 0  # Most recent average offset (us)\n",
    "        self.skew = 0           # Most recent estimated skew (ppm)\n",
    "        self.P = 1              # Parameter used in RLS\n",
    "\n",
    "        self.mu_T_sec_hist = []\n",
    "        self.batch_end_time_sec_hist = []\n",
    "        self.elapsed_time_sec_hist = []\n",
    "        self.acc_offset_us_hist = []\n",
    "        self.avg_offset_us_hist = []\n",
    "        self.skew_hist = []\n",
    "        self.error_hist = []\n",
    "\n",
    "        # CUSUM\n",
    "        self.is_detected = 0\n",
    "\n",
    "        self.n_init = 50  # Number of error samples for initializing mu_e and sigma_e\n",
    "        self.k_CUSUM_start = self.n_init + 1  # CUSUM starts after mu and sigma are initialized\n",
    "\n",
    "        self.Gamma = 5  # Control limit threshold\n",
    "        self.gamma = 4  # Update threshold\n",
    "        self.kappa = 8  # Sensitivity parameter in CUSUM\n",
    "\n",
    "        self.L_upper = 0  # Most recent upper control limit\n",
    "        self.L_lower = 0  # Most recent upper control limit\n",
    "        self.e_ref = []   # Reference (un-normalized) error samples; used to compute mu_e and sigma_e\n",
    "\n",
    "        self.L_upper_hist = []\n",
    "        self.L_lower_hist = []\n",
    "\n",
    "    # `a` is a 1-by-N vector that contains arrival timestamps of the latest batch.\n",
    "    def update(self, a):\n",
    "        if len(a) != self.N:\n",
    "            raise ValueError('Inconsistent batch size')\n",
    "\n",
    "        self.k += 1\n",
    "        self.batch_end_time_sec_hist.append(a[-1])\n",
    "\n",
    "        if self.k == 1:     # Initialize something in the first batch\n",
    "            if self.mode == 'state-of-the-art':\n",
    "                self.mu_T_sec = np.mean(a[1:] - a[:-1])\n",
    "            return\n",
    "\n",
    "        # CIDS officially starts from the second batch\n",
    "        if self.k == 2:\n",
    "            self.init_time_sec = a[0]\n",
    "\n",
    "        if self.k >= 2:\n",
    "            curr_avg_offset_us, curr_acc_offset_us = self.estimate_offset(a)\n",
    "            curr_error_sample = self.update_clock_skew(curr_avg_offset_us, curr_acc_offset_us)\n",
    "            self.update_cusum(curr_error_sample)\n",
    "\n",
    "    def estimate_offset(self, a):\n",
    "        self.elapsed_time_sec = a[-1] - self.init_time_sec\n",
    "        self.elapsed_time_sec_hist.append(self.elapsed_time_sec)\n",
    "\n",
    "        prev_mu_T_sec = self.mu_T_sec           # You will use it later.\n",
    "        self.mu_T_sec = np.mean(a[1:] - a[:-1])\n",
    "        self.mu_T_sec_hist.append(self.mu_T_sec)\n",
    "\n",
    "        prev_acc_offset_us = self.acc_offset_us # You will use it later.\n",
    "        a0 = self.batch_end_time_sec_hist[-2]   # Arrival timestamp of the last message in the previous batch\n",
    "                                                # You will use it later. \n",
    "\n",
    "        curr_avg_offset_us, curr_acc_offset_us = 0, 0\n",
    "\n",
    "        if self.mode == 'state-of-the-art':\n",
    "            # ====================== Start of Your Code =========================\n",
    "            # TODO: Compute curr_avg_offset_us and curr_acc_offset_us for state-of-the-art IDS\n",
    "\n",
    "            # Your code goes here. \n",
    "            SUM = 0\n",
    "            for i in range(1, self.N):\n",
    "                SUM += (a[i] - ((a[0] + i) * prev_mu_T_sec))\n",
    "                \n",
    "            curr_avg_offset_us = SUM / self.N\n",
    "            curr_acc_offset_us = prev_acc_offset_us + abs(curr_avg_offset_us)\n",
    "            \n",
    "            # ====================== End of Your Code =========================\n",
    "\n",
    "        elif self.mode == 'ntp-based':\n",
    "            # ====================== Start of Your Code =========================\n",
    "            # TODO: Compute curr_avg_offset_us and curr_acc_offset_us for NTP-based IDS\n",
    "\n",
    "            # Your code goes here. \n",
    "            #Andres Contribution:\n",
    "            \n",
    "            cur_avg_offset_us = self.T - ((a[self.N] - a[0])/self.N)\n",
    "            curr_acc_offset_us = curr_acc_offset_us + self.N * cur_avg_offset_us  \n",
    "\n",
    "            # ====================== End of Your Code =========================\n",
    "\n",
    "        return curr_avg_offset_us, curr_acc_offset_us\n",
    "\n",
    "    def update_clock_skew(self, curr_avg_offset_us, curr_acc_offset_us):\n",
    "        prev_skew = self.skew\n",
    "        prev_P = self.P\n",
    "\n",
    "        # Compute identification error\n",
    "        time_elapsed_sec = self.elapsed_time_sec\n",
    "        curr_error = curr_acc_offset_us - prev_skew * time_elapsed_sec\n",
    "\n",
    "        # ====================== Start of Your Code =========================\n",
    "        # RLS algorithm\n",
    "        # Inputs:\n",
    "        #   t[k] -> time_elapsed_sec\n",
    "        #   P[k-1] -> prev_P\n",
    "        #   S[k-1] -> prev_skew\n",
    "        #   e[k] -> curr_error\n",
    "        #   lambda -> l\n",
    "        #\n",
    "        # Outputs:\n",
    "        #   P[k] -> curr_P\n",
    "        #   S[k] -> curr_skew\n",
    "        #\n",
    "        # TODO: Implement the RLS algorithm\n",
    "\n",
    "        # Your code goes here. \n",
    "        #Andres Contribution\n",
    "        def Recursive_Least_Squares(time_elapsed_sec, prev_P, prev_skew, curr_error,k, l):\n",
    "            e = curr_error\n",
    "            #G = gain at current k\n",
    "            G = ((1/l)*prev_P*time_elapsed_sec)/(1 + (1/l)((time_elapsed_sec)**2)*prev_P)\n",
    "            \n",
    "            #calculating Curr_P and curr_skew\n",
    "            curr_P = (1/l)*(prev_P - G*time_elapsed_sec*prev_P)\n",
    "            curr_skew = prev_skew + G*curr_error\n",
    "            \n",
    "            return curr_P, curr_skew\n",
    "        \n",
    "        # ====================== End of Your Code =========================\n",
    "\n",
    "        # Update the state of IDS\n",
    "        self.avg_offset_us = curr_avg_offset_us\n",
    "        self.acc_offset_us = curr_acc_offset_us\n",
    "        self.skew = curr_skew\n",
    "        self.P = curr_P\n",
    "\n",
    "        self.avg_offset_us_hist.append(curr_avg_offset_us)\n",
    "        self.acc_offset_us_hist.append(curr_acc_offset_us)\n",
    "        self.skew_hist.append(curr_skew)\n",
    "        self.error_hist.append(curr_error)\n",
    "\n",
    "        return curr_error\n",
    "\n",
    "    def update_cusum(self, curr_error_sample):\n",
    "        if self.k <= self.k_CUSUM_start:\n",
    "            self.e_ref.append(curr_error_sample)\n",
    "            return\n",
    "\n",
    "        prev_L_upper = self.L_upper\n",
    "        prev_L_lower = self.L_lower\n",
    "\n",
    "        # Compute mu_e and sigma_e\n",
    "        e_ref_arr = np.asarray(self.e_ref)\n",
    "        mu_e = np.mean(e_ref_arr)\n",
    "        sigma_e = np.std(e_ref_arr)\n",
    "\n",
    "        kappa = self.kappa\n",
    "\n",
    "        # ====================== Start of Your Code =========================\n",
    "        # TODO: 1) Normalize curr_error_sample, 2) compute curr_L_upper and curr_L_lower\n",
    "        # Store the normalized error in `normalized_error`\n",
    "\n",
    "        # Your code goes here. \n",
    "        #Andres contribution:\n",
    "        \n",
    "        #compute normalized error\n",
    "        normalized_error = (curr_error_sample - mu_e)/sigma_e\n",
    "        \n",
    "        #compute L^+ and L^-\n",
    "        curr_L_upper = max(0, prev_L_upper + normalized_error - kappa)\n",
    "        curr_L_lower = max(0, prev_L_lower - normalized_error - kappa)\n",
    "        \n",
    "        # ====================== End of Your Code =========================\n",
    "\n",
    "        if (curr_L_upper > self.Gamma) | (curr_L_lower > self.Gamma):\n",
    "            self.is_detected = True\n",
    "\n",
    "        # Store valid (un-normalized) error sample\n",
    "        if abs(normalized_error) < self.gamma:\n",
    "            self.e_ref.append(curr_error_sample)\n",
    "\n",
    "        # Update the state of CUSUM\n",
    "        self.L_upper = curr_L_upper\n",
    "        self.L_lower = curr_L_lower\n",
    "\n",
    "        self.L_upper_hist.append(curr_L_upper)\n",
    "        self.L_lower_hist.append(curr_L_lower)"
   ]
  }
 ],
 "metadata": {
  "kernelspec": {
   "display_name": "Python 3",
   "language": "python",
   "name": "python3"
  },
  "language_info": {
   "codemirror_mode": {
    "name": "ipython",
    "version": 3
   },
   "file_extension": ".py",
   "mimetype": "text/x-python",
   "name": "python",
   "nbconvert_exporter": "python",
   "pygments_lexer": "ipython3",
   "version": "3.8.8"
  }
 },
 "nbformat": 4,
 "nbformat_minor": 5
}
